name: üîÑ Release Preparation

on:
  push:
    branches: [preview]

jobs:
  # üîÑ Release preparation - runs on push to preview (after merge)
  release-preparation:
    name: üîÑ Release Preparation
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
      pull-requests: read

    steps:
      - name: ‚¨áÔ∏è Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history for changelog generation
          token: ${{ secrets.GITHUB_TOKEN }}
          persist-credentials: true

      - name: üì¶ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.11.1

      - name: üü¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: pnpm

      - name: üì• Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üè∑Ô∏è Get last release tag
        id: last_release
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "Last release tag: $LAST_TAG"

      - name: üìù Get commit messages since last release
        id: commits
        run: |
          COMMITS=$(git log ${{ steps.last_release.outputs.tag }}..HEAD --pretty=format:"%h %s%n%b" | head -50)
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "Recent commits since ${{ steps.last_release.outputs.tag }}:"
          echo "$COMMITS"

      - name: üîç Determine version bump type
        id: version_bump
        run: |
          # Store commit messages safely in temporary file to avoid shell interpretation issues
          cat << 'COMMITS_EOF' > commits_temp.txt
          ${{ steps.commits.outputs.commits }}
          COMMITS_EOF

          # Check for breaking changes (major bump) - must be at start of line or after newline
          if grep -E "(^|[\n])BREAKING CHANGE:|!:" commits_temp.txt ; then
            echo "type=major" >> $GITHUB_OUTPUT
            echo "Version bump: MAJOR (breaking changes detected)"
          # Check for features (minor bump) - only in commit subject lines
          elif grep -E "^[a-f0-9]+ feat\(|^[a-f0-9]+ feat:" commits_temp.txt ; then
            echo "type=minor" >> $GITHUB_OUTPUT
            echo "Version bump: MINOR (new features detected)"
          # Default to patch
          else
            echo "type=patch" >> $GITHUB_OUTPUT
            echo "Version bump: PATCH (fixes and improvements)"
          fi

          # Clean up temporary file
          rm -f commits_temp.txt

      - name: üìà Update package version
        id: version_update
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"

          # Use npm version to bump
          NEW_VERSION=$(npm version ${{ steps.version_bump.outputs.type }} --no-git-tag-version)
          NEW_VERSION=${NEW_VERSION#v}  # Remove 'v' prefix

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: ü§ñ Generate changelog entry with OpenAI
        id: changelog
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          OPENAI_MODEL: ${{ secrets.OPENAI_MODEL || 'gpt-4o-mini' }}
        run: |
          # Prepare data for OpenAI
          CURRENT_DATE=$(date +"%Y-%m-%d")
          VERSION="${{ steps.version_update.outputs.version }}"

          # Store commits safely in temporary file to avoid shell interpretation issues
          cat << 'COMMITS_EOF' > commits_temp.txt
          ${{ steps.commits.outputs.commits }}
          COMMITS_EOF

                    # Use jq to build the final JSON safely, avoiding sed issues with special characters
          COMMITS_CONTENT=$(cat commits_temp.txt)

          # Build the JSON payload using jq to avoid sed escaping issues
          jq -n \
            --arg model "$OPENAI_MODEL" \
            --arg version "$VERSION" \
            --arg date "$CURRENT_DATE" \
            --arg commits "$COMMITS_CONTENT" \
            '{
              "model": $model,
              "messages": [
                {
                  "role": "system",
                  "content": "You are an expert technical writer who creates changelog entries following Keep a Changelog standards. Generate entries that are FOR HUMANS, not machines - focus on what end users and developers need to know. ONLY use these standard categories: Added (new features), Changed (changes in existing functionality), Deprecated (soon-to-be removed features), Removed (now removed features), Fixed (bug fixes), Security (vulnerabilities). Be specific about technical impact but NEVER invent or hallucinate features that don't exist. If no meaningful changes are provided, generate a minimal entry like '\''### Changed\\n- Minor updates and improvements'\''."
                },
                {
                  "role": "user",
                  "content": ("Generate a changelog entry for version " + $version + " with date " + $date + ". Recent commits:\n\n" + $commits + "\n\nIMPORTANT: If the commits list above is empty or contains no meaningful changes, respond with ONLY:\n### Changed\n- Minor updates and improvements\n\nIf you have actual commits, analyze them carefully and create entries that help users understand what changed and how it affects them. This is for the setlistfm-ts TypeScript SDK. Focus on user-facing changes, API modifications, and developer experience improvements. Be accurate and never invent features.")
                }
              ],
              "max_tokens": 1500,
              "temperature": 0.3
            }' > changelog_prompt.json

          # Debug: Show the JSON payload size and structure
          echo "Debug: JSON payload size: $(wc -c < changelog_prompt.json) bytes"
          echo "Debug: JSON structure validation:"
          jq empty changelog_prompt.json && echo "JSON is valid" || echo "JSON is invalid"

          # Fallback changelog content
          FALLBACK_CHANGELOG="### Changed
          - Minor updates and improvements
          - Enhanced CI/CD pipeline
          - Updated dependencies and tooling"

          # Check if OpenAI API key is available
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "Warning: OPENAI_API_KEY not found, using fallback changelog"
            CHANGELOG_ENTRY="$FALLBACK_CHANGELOG"
          else
            # Call OpenAI API with better error handling
            echo "Calling OpenAI API..."
            API_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d @changelog_prompt.json \
              https://api.openai.com/v1/chat/completions)

            # Extract HTTP status code and response body
            HTTP_CODE=$(echo "$API_RESPONSE" | tail -n1)
            RESPONSE_BODY=$(echo "$API_RESPONSE" | head -n -1)

            echo "Debug: HTTP Status Code: $HTTP_CODE"

            # Check if API call was successful
            if [ "$HTTP_CODE" -eq 200 ]; then
              # Extract changelog content
              CHANGELOG_ENTRY=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // empty')

              if [ -z "$CHANGELOG_ENTRY" ] || [ "$CHANGELOG_ENTRY" = "null" ]; then
                echo "Warning: Empty response from OpenAI, using fallback"
                echo "Debug: API Response: $RESPONSE_BODY"
                CHANGELOG_ENTRY="$FALLBACK_CHANGELOG"
              else
                echo "Successfully generated changelog with OpenAI"
              fi
            else
              echo "Error: OpenAI API call failed with status $HTTP_CODE"
              echo "Debug: Error Response: $RESPONSE_BODY"
              echo "Using fallback changelog"
              CHANGELOG_ENTRY="$FALLBACK_CHANGELOG"
            fi
          fi

          # Clean up temporary files
          rm -f commits_temp.txt changelog_prompt.json

          # Save changelog entry
          echo "changelog_entry<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG_ENTRY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "Final changelog entry:"
          echo "$CHANGELOG_ENTRY"

      - name: üìù Update CHANGELOG.md
        run: |
          # Create temp file with new entry
          echo "## [${{ steps.version_update.outputs.version }}] - $(date +%Y-%m-%d)" > new_entry.md
          echo "" >> new_entry.md

          # Write changelog entry safely to avoid shell interpretation
          cat << 'CHANGELOG_EOF' >> new_entry.md
          ${{ steps.changelog.outputs.changelog_entry }}
          CHANGELOG_EOF

          echo "" >> new_entry.md
          echo "---" >> new_entry.md
          echo "" >> new_entry.md

          # Insert new entry after the header in CHANGELOG.md
          head -n 9 CHANGELOG.md > temp_changelog.md
          cat new_entry.md >> temp_changelog.md
          tail -n +10 CHANGELOG.md >> temp_changelog.md
          mv temp_changelog.md CHANGELOG.md

          # Clean up
          rm new_entry.md

      - name: üíæ Commit version and changelog updates
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add package.json CHANGELOG.md
          git commit -m "chore(release): bump version to ${{ steps.version_update.outputs.version }} and update changelog"
          git push

      - name: üéâ Release preparation summary
        run: |
          echo "## üéâ Release Preparation Completed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üè∑Ô∏è **Version**: ${{ steps.version_update.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "üìà **Bump Type**: ${{ steps.version_bump.outputs.type }}" >> $GITHUB_STEP_SUMMARY
          echo "üìù **Changelog**: Generated and updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the version bump and changelog entry" >> $GITHUB_STEP_SUMMARY
          echo "2. Create PR from preview ‚Üí main when ready to publish" >> $GITHUB_STEP_SUMMARY
          echo "3. Merge to main will trigger GitHub release and npm publishing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üöÄ **Preview branch is ready for production release!**" >> $GITHUB_STEP_SUMMARY
